# -*- coding: utf-8 -*-
"""Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K01-ABZrH9GydsVy3_BEY9R1rk48m2nD

#Rubrica Project
ContactEase Solutions mira a semplificare la gestione dei contatti telefonici per i propri utenti, sviluppando un software intuitivo e interattivo che ottimizza l’organizzazione e l’accesso alle informazioni personali.

Gli utenti spesso trovano difficoltoso gestire e organizzare i loro contatti telefonici in modo efficiente. Esistono poche soluzioni semplici e intuitive che permettano di aggiungere, modificare, eliminare, visualizzare e cercare contatti in un unico luogo, direttamente dal terminale.

ContactEase Solutions fornirà un’applicazione console interattiva che, grazie ai principi della programmazione orientata agli oggetti (OOP) in Python, permetterà una gestione dei contatti semplice e strutturata. Gli utenti potranno facilmente salvare e caricare i contatti in un formato file (ad
esempio JSON), garantendo una gestione dati efficiente e sicura.

##Requisiti del Progetto:
* OOP in Python: Implementare i concetti di OOP per una struttura solida e
scalabile.
* Struttura Dati: Creare una struttura di dati efficiente per memorizzare i contatti.
* Interfaccia Utente: Sviluppare un’interfaccia da linea di comando interattiva e facile da usare.
Funzionalità:
* Aggiunta di un Contatto: Permettere l'inserimento di nuovi contatti.
* Visualizzazione dei Contatti: Mostrare tutti i contatti presenti.
* Modifica di un Contatto: Consentire la modifica dei dettagli dei contatti esistenti.
* Eliminazione di un Contatto: Rimuovere contatti dalla rubrica.
* Ricerca di un Contatto: Cercare contatti per nome o cognome.
* Salvataggio e Caricamento: Salvare i contatti in un file e caricarli all’avvio.

##Interfaccia Utente:
L’interfaccia sarà basata su riga di comando, offrendo un menu principale con opzioni chiare per le varie operazioni, garantendo così una user experience fluida e accessibile anche per gli utenti meno esperti.
"""

import os
import json
import pandas as pd
import re
from csv import excel
import json

# This portion of code create a folder called "data" with two dictionary that will be used
# in the Phone_Book class
#In normal enviroment a folder called "data" with these dict is present
current_directory = os.getcwd()
data_folder_path = os.path.join(current_directory,"data")
if not (os.path.isdir(data_folder_path)):
       os.makedirs(data_folder_path)

input_dict = {
    "start":"\n What do you want to do?[ADD/view/modify/search/delete/end]  ",
    "search":"\n Inser name or surname of the contact that you want to search: ",
    "search_email":"\n Inser name or surname of the contact that you want to search: ",
    "mod_name":"\n Insert name of the contact that you want to modify:  ",
    "mod_sur":"\n Insert  surname of the contact that you want to search:  ",
    "mod_email":"\n Insert the email of the contact that you want to modify:  ",
    "mod_field":"\n What field do you want to modify?[PHONE_NUMBER/name/surname/email]  ",
    "more_mod":"\n Do you want to modify more? [y/N]  ",
    "del_email":"\n Select the email that you want to delete:  ",
    "del_name":"\n Select the name that you want to delete:  ",
    "del_sur":"\n Select the surname that you want to delete:  ",
    "name" :"\n Insert name to add:  ",
    "surname":"\n Insert surname to add:  ",
    "email": "\n Insert email to add:  ",
    "phone_number": "\n Insert phone number to add:  ",
    "del_all" : "\n Multiple Contact with same name founded.\nDelete all? [y/N]"
 }

print_dict = {
    "start":"\n\n Welcome to your Phone Book :) \n",
    "bad_input":"\n Input not correct ",
    "empty_df":"\n Phone Book is empty ",
    "no_match":"\n Match not found ",
    "n_match":"\n Multiple match found ",
    "no_match":"\n No match found ",
    "close" : "\n\n Bye Bye :)"
 }

print_dict_path = os.path.join(data_folder_path,"print_dict.json")
input_dict_path = os.path.join(data_folder_path,"input_dict.json")

with open(print_dict_path,"w") as file_json :
  json.dump(print_dict, file_json , indent = 4)

with open(input_dict_path,"w") as file_json :
  json.dump(input_dict, file_json , indent = 4)

class PhoneBook():

  def __init__(self):
    """
    Phone Book class
    Checks if the Phone_Book csv file is present or create a new one

    """
    self._current_dir = os.getcwd()
    self._phone_book_csv_path="phone_book.csv"
    self.__field_value =  ['name', 'surname', 'phone_number', "email"]
    if os.path.exists(self._phone_book_csv_path):
      self.phone_book_df = pd.read_csv(self._phone_book_csv_path)
    else:
      self.phone_book_df = pd.DataFrame(columns=self.__field_value)

    self._print_func("start")


  def start(self):
    """
    Start Func

    """
    flag = True
    while flag:
      input_cmd = self._input_func("start")
      if input_cmd.lower() in ["add","view","modify","search","delete","end"]:
        flag = self._check_command(input_cmd.lower())
      else:
        self._print_func("bad_input")



  def close(self):
    """
    Close the PhoneBook and save the modifies
    """
    self.phone_book_df.to_csv(self._phone_book_csv_path, index = False)
    self._print_func("close")
    return False



  def search_contact(self):
    """
    Search a specif contact in the DataFrame
    """
    self.__is_dataframe_empty()
    search_name = self._input_func("search")
    index_search = self._find_index(search_name)

    if len(index_search) == 0:
      self._print_func("no_match")
    else:
      search_df = self.phone_book_df.iloc[index_search]
      print(search_df)
    return True




  def modify_contact(self):
    """
    Modify the DataFrame searching by name and surname. If there are two contact with the same name and surname
    email must be used.

    """
    self.__is_dataframe_empty()
    search_name = self._input_func("mod_name")
    search_surname =  self._input_func("mod_sur")
    index_search = self._find_index(search_name,search_surname)

    if len(index_search) == 0 :
      self._print_func("no_match")
      return True
    else:
      if len(index_search) >= 2:

        multiple_contact = self.phone_book_df.iloc[index_search]
        self._print_func("n_match")
        print(multiple_contact)
        search_email = self._input_func("mod_email")
        index_search = self._find_index(search_name,search_surname,search_email)

      modify_flag = True
      while modify_flag :
        modify_flag = self.__modify_field(index_search)
      self._save_df()
      return True
    

  def delete_contact(self):
    """
    Delete a specifc contac from the DataFrame

    """
    self.__is_dataframe_empty()
    name = self._input_func("del_name")
    surname = self._input_func("del_sur")
    index_to_remove = self._find_index(name,surname)


    if len(index_to_remove) == 0 :
      self._print_func("no_match")
    elif len(index_to_remove) == 1:
      self.phone_book_df = self.phone_book_df.drop(index_to_remove[0])
    elif len(index_to_remove) >= 2:
      command = self._Input_Func("del_all")
      if command.lower() in ["y","n"]:
        if command == "y":
          for i in index_to_remove:
            self.phone_book_df = self.phone_book_df.drop(i)
            print("Contact Removed \n")
        if command == "n":
          email = input ("Select the email that you want to delete")
          index_to_remove = self._find_index(name,surname,email)
          self.phone_book_df = self.phone_book_df.drop(index_to_remove[0])
          print("Contact Removed \n")

    self._save_df()
    return True






  def view_all_contact(self):
    """
    Print all contacts in the dataframe
    """
    self.__is_dataframe_empty()
    print(self.phone_book_df)
    return True


  def add_contact(self):
    """
    Add a contact in the dataframe

    """
    contact_dictionary={}
    for type_of_input in self.__field_value :
      correct_flag = False
      while correct_flag == False:
        input_values = self._input_func(type_of_input)
        correct_flag = self._is_input_correct(type_of_input,input_values)

        if correct_flag :
          contact_dictionary[type_of_input] = str(input_values)

    temp_df = pd.DataFrame([contact_dictionary])
    self.phone_book_df = pd.concat([self.phone_book_df , temp_df], ignore_index=True)
    self._save_df()
    print('Sucessfully Added \n')
    return True




  def __modify_field(self,index_to_search):
    """
    Modify the field of a specific user 

    index_to_search --> index of the dataframe related to the user that we want to modify 
    """
    field_2_modify = self._input_func("mod_field")
    if field_2_modify.lower() in ["name","surname","phone_number","email"]:
          correct_input = False
          while correct_input == False:
            modified_value = input(f"inser new {field_2_modify} :")
            correct_input = self._is_input_correct(field_2_modify,modified_value)
          self.phone_book_df.iloc[index_to_search , self.phone_book_df.columns.get_loc(field_2_modify)] = str(modified_value)
          more_modify = self._input_func("more_mod")
          if not self._loop_modify(more_modify,index_to_search):
            return False

    else:
      self._print_func("bad_input")
      self.__modify_field(index_to_search)


  def _loop_modify(self,cmd,index_to_modify):
    """
    Internalfunction used to check the promp command in the _modify_field
    """
    if cmd.lower() in ["y","n"]:
              if cmd.lower() == "y":
                self.__modify_field(index_to_modify)  
              else:
                return False
    else:
      self._print_func("bad_input")
      self._loop_modify("",index_to_modify)


  def _check_command(self,cmd):
    """
    cmd --> (str) string that be used to call specif function base on the parameter
            ["add","view","delete","modify","search","end"]
    """
    cmd_dictionary={
        "add" : self.add_contact,
        "view" : self.view_all_contact,
        "delete": self.delete_contact,
        "modify" : self.modify_contact,
        "search" : self.search_contact,
        "end" : self.close
        }
    return cmd_dictionary[cmd]()


  def _save_df(self):
    self.phone_book_df.to_csv(self._phone_book_csv_path, index = False)



  def __is_dataframe_empty(self):
    """
    Check if the Dataframe is empty

    """
    if self.phone_book_df.empty:
      self._print_func("empty_df")
      self.start()





  def _find_index(self,*args):
    """
    Find the index of the dataframe that fills the inputs


    args[0] --> (string) name/surname of the contact to be searched
    args[1] --> (string) surname of the contact to be searched
    args[2] --> (strin) email of the contact to be searched

    """
    if len(args) == 1:
      index= self.phone_book_df.index[(self.phone_book_df["name"] == args[0]) |(self.phone_book_df["surname"] == args[0])].tolist()
      return index
    elif len(args) ==2 :
      index= self.phone_book_df.index[(self.phone_book_df["name"] == args[0]) & (self.phone_book_df["surname"] == args[1]) ].tolist()
      return index

    elif len(args) ==3 :
      index= self.phone_book_df.index[(self.phone_book_df["name"] == args[0]) & (self.phone_book_df["surname"] == args[1]) & (self.phone_book_df["email"] == args[2]) ].tolist()
      return index





  def _input_func(self,input_type):
    """
    Input frase based on the case

    input_type --> "start ", "search" , "mod_name","mod_sur" , "mod_email" , "mod_field" , "more_mod"

    """

    #file_path_drive=r"/content/drive/MyDrive/Colab Notebooks/Profession AI/Python Course/Progetto Rubrica Contatti/data/input_dict.json"

    input_dict_path = os.path.join(self._current_dir,"data/input_dict.json")

    with open(input_dict_path,"r") as file :
      input_dict = json.load(file)

    cmd = input(input_dict[input_type])
    return cmd






  def _print_func(self,print_type):
      """
      Print func that display frases based on input and check the string in the json file in
      Data folder

      print_type --> (string) can be used :
                                          "start"
                                          "bad_input"
                                          "empty_df"
                                          "no_match"
                                          "n_match"
                                          "close"
      """
      #file_path_drive = r"/content/drive/MyDrive/Colab Notebooks/Profession AI/Python Course/Progetto Rubrica Contatti/data/print_dict.json"

      print_dict_path = os.path.join(self._current_dir,"data/print_dict.json")

      with open(print_dict_path,"r") as file :
        print_dict = json.load(file)

      print(print_dict[print_type])





  def _is_input_correct(self,input_name,input_value):
    """
    Check if the input are correctly written.
    - name and surname must contains only alphabets
    - phone_number must be only numeric
    - email must be setted ad "aaZZ_1-9_!"@"aa_zZ_1_9"."aa_ZZ"


    input_name --> (string) keywork of the label of the Phone Book (e.g "Name")
    input_value --> (string) value of the label  (e.g "Marco")
    """

    if input_name in  ("name","surname"):
      if not(input_value.isalpha()):
        self._print_func("bad_input")
        return False
      else:
        return True

    elif input_name == "phone_number":
      if not(input_value.isnumeric()):
        self._print_func("bad_input")
        return False
      else:
        return True

    elif input_name == "email":
      regex = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,7}\b'
      if not(re.fullmatch(regex, input_value)):
        self._print_func("bad_input")
        return False
      else:
        return True



r = PhoneBook()
r.start()